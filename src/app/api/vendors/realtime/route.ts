import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const vendorId = searchParams.get('vendorId');

    if (!vendorId) {
      return NextResponse.json(
        { error: 'Vendor ID is required' },
        { status: 400 }
      );
    }

    // Get vendor details
    const vendor = await db.vendor.findUnique({
      where: { id: vendorId }
    });

    if (!vendor) {
      return NextResponse.json(
        { error: 'Vendor not found' },
        { status: 404 }
      );
    }

    // Simulate real-time vendor status monitoring with more realistic scenarios
    const scenarios = [
      {
        status: 'operational',
        responseTime: Math.floor(Math.random() * 200) + 50,
        uptime: 99.5 + Math.random() * 0.4,
        incidents: []
      },
      {
        status: 'degraded',
        responseTime: Math.floor(Math.random() * 1000) + 500,
        uptime: 95 + Math.random() * 4,
        incidents: [
          {
            id: Date.now().toString(),
            title: 'Performance degradation detected',
            severity: 'moderate',
            startTime: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
            description: 'Elevated response times affecting service performance'
          }
        ]
      },
      {
        status: 'outage',
        responseTime: 0,
        uptime: 85 + Math.random() * 10,
        incidents: [
          {
            id: Date.now().toString(),
            title: 'Service outage detected',
            severity: 'critical',
            startTime: new Date(Date.now() - 1800000).toISOString(), // 30 minutes ago
            description: 'Complete service interruption affecting all operations'
          }
        ]
      }
    ];

    // Weighted random selection (80% operational, 15% degraded, 5% outage)
    const random = Math.random();
    const selectedScenario = random < 0.8 ? scenarios[0] : random < 0.95 ? scenarios[1] : scenarios[2];

    const monitoringResult = {
      vendorId: vendor.id,
      vendorName: vendor.name,
      status: selectedScenario.status,
      responseTime: selectedScenario.responseTime,
      lastChecked: new Date().toISOString(),
      uptime: selectedScenario.uptime,
      incidents: selectedScenario.incidents,
      metrics: {
        availability: selectedScenario.uptime,
        performance: selectedScenario.responseTime < 500 ? 'good' : selectedScenario.responseTime < 1000 ? 'fair' : 'poor',
        reliability: selectedScenario.status === 'operational' ? 'high' : selectedScenario.status === 'degraded' ? 'medium' : 'low'
      }
    };

    // Create monitoring log entry
    await db.monitoringLog.create({
      data: {
        vendorId: vendor.id,
        status: monitoringResult.status,
        responseTime: monitoringResult.responseTime,
        details: JSON.stringify(monitoringResult)
      }
    });

    // Create compliance alert for critical issues
    if (monitoringResult.status === 'outage' || (monitoringResult.status === 'degraded' && vendor.criticality === 'Critical')) {
      await db.complianceAlert.create({
        data: {
          title: `Vendor ${monitoringResult.status === 'outage' ? 'Outage' : 'Degradation'}: ${vendor.name}`,
          description: `${vendor.name} is experiencing ${monitoringResult.status}. Response time: ${monitoringResult.responseTime}ms. Uptime: ${monitoringResult.uptime.toFixed(1)}%.`,
          source: 'Real-time Vendor Monitoring',
          category: 'Vendor Risk',
          riskLevel: monitoringResult.status === 'outage' ? 'High' : 'Medium',
          severity: monitoringResult.status === 'outage' ? 'Critical' : 'High',
          priority: monitoringResult.status === 'outage' ? 1 : 2,
          publishedAt: new Date(),
          metadata: JSON.stringify({
            vendorId: vendor.id,
            vendorName: vendor.name,
            criticality: vendor.criticality,
            monitoringResult,
            autoGenerated: true
          })
        }
      });
    }

    return NextResponse.json(monitoringResult);

  } catch (error) {
    console.error('Error monitoring vendor:', error);
    return NextResponse.json(
      { error: 'Failed to monitor vendor' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { vendorIds, enableRealTime = false } = body;

    if (!vendorIds || !Array.isArray(vendorIds)) {
      return NextResponse.json(
        { error: 'vendorIds array is required' },
        { status: 400 }
      );
    }

    const results = [];
    const alertsCreated = [];

    for (const vendorId of vendorIds) {
      try {
        // Get vendor details
        const vendor = await db.vendor.findUnique({
          where: { id: vendorId }
        });

        if (!vendor) {
          results.push({
            vendorId,
            error: 'Vendor not found'
          });
          continue;
        }

        // Enhanced monitoring scenarios with criticality weighting
        let status;
        if (vendor.criticality === 'Critical') {
          // Critical vendors have higher chance of showing issues
          const criticalRandom = Math.random();
          status = criticalRandom < 0.7 ? 'operational' : criticalRandom < 0.9 ? 'degraded' : 'outage';
        } else {
          // Non-critical vendors are more stable
          const normalRandom = Math.random();
          status = normalRandom < 0.85 ? 'operational' : normalRandom < 0.97 ? 'degraded' : 'outage';
        }

        const baseResponseTime = status === 'operational' ? 100 : status === 'degraded' ? 750 : 0;
        const responseTime = baseResponseTime + Math.floor(Math.random() * 200);
        const baseUptime = status === 'operational' ? 99.5 : status === 'degraded' ? 96 : 88;
        const uptime = baseUptime + Math.random() * 2;

        const monitoringResult = {
          vendorId: vendor.id,
          vendorName: vendor.name,
          status,
          responseTime,
          lastChecked: new Date().toISOString(),
          uptime,
          incidents: status !== 'operational' ? [
            {
              id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
              title: `${status === 'outage' ? 'Service outage' : 'Performance degradation'} detected`,
              severity: status === 'outage' ? 'critical' : 'moderate',
              startTime: new Date(Date.now() - (status === 'outage' ? 1800000 : 3600000)).toISOString(),
              description: `${vendor.name} is experiencing ${status}${status === 'outage' ? ' - complete service interruption' : ' - elevated response times'}`
            }
          ] : [],
          metrics: {
            availability: uptime,
            performance: responseTime < 500 ? 'good' : responseTime < 1000 ? 'fair' : 'poor',
            reliability: status === 'operational' ? 'high' : status === 'degraded' ? 'medium' : 'low',
            criticality: vendor.criticality
          }
        };

        // Create monitoring log entry
        await db.monitoringLog.create({
          data: {
            vendorId: vendor.id,
            status: monitoringResult.status,
            responseTime: monitoringResult.responseTime,
            details: JSON.stringify(monitoringResult)
          }
        });

        // Create alert for critical vendors or outage conditions
        if (status === 'outage' || (status === 'degraded' && vendor.criticality === 'Critical')) {
          const alert = await db.complianceAlert.create({
            data: {
              title: `Vendor ${status === 'outage' ? 'Outage' : 'Degradation'}: ${vendor.name}`,
              description: `${vendor.name} (${vendor.criticality} criticality) is experiencing ${status}. Response time: ${responseTime}ms. Uptime: ${uptime.toFixed(1)}%.`,
              source: 'Real-time Vendor Monitoring',
              category: 'Vendor Risk',
              riskLevel: status === 'outage' ? 'High' : 'Medium',
              severity: status === 'outage' ? 'Critical' : 'High',
              priority: status === 'outage' ? 1 : 2,
              publishedAt: new Date(),
              metadata: JSON.stringify({
                vendorId: vendor.id,
                vendorName: vendor.name,
                criticality: vendor.criticality,
                monitoringResult,
                autoGenerated: true,
                realTime: enableRealTime
              })
            }
          });
          alertsCreated.push(alert);
        }

        results.push(monitoringResult);
      } catch (error) {
        console.error(`Error monitoring vendor ${vendorId}:`, error);
        results.push({
          vendorId,
          error: 'Failed to monitor vendor'
        });
      }
    }

    const response = {
      results,
      timestamp: new Date().toISOString(),
      summary: {
        total: vendorIds.length,
        operational: results.filter(r => r.status === 'operational').length,
        degraded: results.filter(r => r.status === 'degraded').length,
        outage: results.filter(r => r.status === 'outage').length,
        alertsCreated: alertsCreated.length
      }
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Error in bulk vendor monitoring:', error);
    return NextResponse.json(
      { error: 'Failed to monitor vendors' },
      { status: 500 }
    );
  }
}